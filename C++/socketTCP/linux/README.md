# 程序说明
---
:art:
---
* server
  * saveData()
    * server接收client发来的一条10字节的初始信息
      * 6bytes检查信息`verify`;
      * client即将要发送的真正的信息的字节数(unsigned int);
    * server在确认接收到初始信息后,向client回信`OK`,表明自己已收到长度信息，可以开始接收信息;
    * `savedata()`接收到真正的信息之后,返回存储真正信息的智能指针;
  * saveFIle()
    * ___传输文件一定要使用二进制格式读写,这样会避免一些不必要的格式问题___;
  * saveFixedStruct()
    * 对于每个成员长度都固定的结构体来说,在同种位数的系统上,结构体的长度也是不变的,其存储方式也是固定的;
    * 所以可以使用memcpy函数将一个结构体的所有成员都放在一个数组中传递;
    * 然后再使用memcpy将buffer中的数据存储到相应结构体的实例中,得到与传输前相同的结构体实例;
  * saveMutableStruct()
    * 由于结构体成员长度是可变的,故而不能使用memcpy函数将所有成员都放在一个数组中,但是可以做一些添加用于区分各个成员;
    * 算法    
      * 对于固定长度的成员,直接使用memcpy将其复制进一个buffer中,并记录位置偏移offset;
      * 对于不固定长度的成员,首先计算其具体长度(例子中unsigned short已足够),将其复制进上面buffer后面,然后再将成员按字节复制到后面的buffer中;
      * 这样在解析的时候,根据复制的顺序,依次得到传递前结构体实例成员的值,进而完成传输;

* client
  * sendData()
    * 首先发送检查信息`verify`加要发送的数据的长度;
    * 获取server发来的OK信息;
    * 发送具体数据;
  * sendFile()
    * 使用二进制打开文件,读取文件信息;
    * 使用成员函数`sendData()`发送文件信息;
  * sendFixedStruct()
    * 将结构体实例直接使用memcpy复制进一个数组中;
    * 使用`sendData()`发送结构体数据;
  * sendMutableStruct()
    * 首先计算需要的数组长度,为其开辟空间;
    * 将结构体信息根据server算法进行复制;
    * 使用`sendData()`发送数据;

* 扩展
  * 修改初始信息,如何使用多线程,使得不管client发送什么样的数据,server都能获取正确的信息;
  * 由于刚看到状态机,决定试试,但是最近比较忙,所以下周应该会出一些构思;
  * 构思
    * client端class不变,主函数发送多个不同类型的消息;
    * server主循环函数一直循环接收,发送相应消息到消息队列中;
    * 使用状态机处理三类信息(强行状态机)
      * 文件;
      * 长度不变结构体;
      * 长度可变结构体;
    * 为什么感觉这么low呢！
